"""
Executor Agent Module
Uses PandasAI SmartDataFrame with OpenAI LLM to execute plans.
"""

import os
import pandas as pd
from typing import Optional, Any, Tuple
from pandasai import SmartDataframe
from pandasai.llm.base import LLM
import openai


class OpenAILLM(LLM):
    """Simple OpenAI LLM wrapper for PandasAI."""
    
    def __init__(self, api_key: str, api_base: str, model: str):
        super().__init__(api_key=api_key)
        self._api_base = api_base
        self._model = model
        self.client = openai.OpenAI(api_key=api_key, base_url=api_base)
    
    @property
    def type(self) -> str:
        return "openai"
    
    def call(self, instruction: Any, context: Any = None) -> str:
        prompt = str(instruction)
        response = self.client.chat.completions.create(
            model=self._model,
            messages=[{"role": "user", "content": prompt}],
            temperature=0.1,
        )
        return response.choices[0].message.content


class ExecutorAgent:
    """Executor that uses PandasAI SmartDataFrame with the plan from Planner."""

    def __init__(self):
        self.api_key = os.getenv("LITELLM_API_KEY")
        self.api_base = os.getenv("LITELLM_API_BASE", "https://litellm.koboi2026.biz.id/v1")
        
        if not self.api_key:
            raise ValueError("LITELLM_API_KEY not found")
        
        self.model = "gemini/gemini-2.0-flash"
        self.llm = OpenAILLM(self.api_key, self.api_base, self.model)
        self.smart_df: Optional[SmartDataframe] = None
    

    def set_dataframe(self, df: pd.DataFrame) -> None:
        """Set dataframe and create PandasAI SmartDataframe."""
        self.smart_df = SmartDataframe(df, config={"llm": self.llm})
    

    def execute(
        self,
        plan: Any,
        df: pd.DataFrame,
        question: str
    ) -> Tuple[str, Optional[pd.DataFrame], Optional[str]]:
        """Execute the plan using PandasAI SmartDataFrame.
        
        Returns:
            Tuple of (answer, result_df, image_path)
        """
        try:
            if self.smart_df is None:
                self.set_dataframe(df)
            
            # Track existing chart files before execution
            charts_dir = "exports/charts"
            existing_charts = set()
            if os.path.exists(charts_dir):
                existing_charts = set(os.listdir(charts_dir))
            
            # Build prompt from plan
            prompt = f"""Execute this plan:
Goal: {plan.goal}
Steps: {', '.join(plan.steps)}
Columns: {plan.columns_to_use}
Aggregation: {plan.aggregation}

Original question: {question}"""
            
            # Use PandasAI SmartDataframe to execute
            result = self.smart_df.chat(prompt)
            
            # Check for new chart files generated by PandasAI
            image_path = None
            if os.path.exists(charts_dir):
                current_charts = set(os.listdir(charts_dir))
                new_charts = current_charts - existing_charts
                if new_charts:
                    newest_chart = max(new_charts)
                    image_path = os.path.join(charts_dir, newest_chart)
            
            # Also check if result is a PNG path directly
            if isinstance(result, str) and result.endswith('.png') and os.path.exists(result):
                image_path = result
            
            # Format the answer
            if image_path:
                answer = "Here's the generated chart:"
            elif result is None:
                answer = "No results."
            elif isinstance(result, pd.DataFrame):
                answer = result.head(10).to_string()
            elif isinstance(result, (int, float)):
                answer = f"{result:,.2f}" if isinstance(result, float) else f"{result:,}"
            else:
                answer = str(result)
            
            # Return DataFrame if visualization was requested
            result_df = result if isinstance(result, pd.DataFrame) else None
            
            return answer, result_df, image_path
            
        except Exception as e:
            return f"Error: {str(e)}", None, None
